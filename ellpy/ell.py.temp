# -*- coding: utf-8 -*-
import numpy as np
import math


class ell:

    def __init__(self, val, x):
        '''ell = { x | (x - xc)' * P^-1 * (x - xc) <= 1 }'''
        self._use_parallel = True
        self._n = n = len(x)
        self.c1 = float(n * n) / (n * n - 1.)
        self._xc = x.copy()
        if np.isscalar(val):
            self.Q = np.eye(n)
            self.kappa = val
        else:
            self.Q = np.diag(val)
            self.kappa = 1.

    def copy(self):
        E = ell(0, self.xc.copy())
        E.Q = self.Q.copy()
        E.c1 = self.c1
        E.kappa = self.kappa
        E._use_parallel = self._use_parallel
        return E

    @property
    def xc(self):
        return self._xc

    @xc.setter
    def xc(self, x):
        self._xc = x

    @property
    def use_parallel(self):
        return self._use_parallel

    @use_parallel.setter
    def use_parallel(self, b):
        self._use_parallel = b

    def update_core(self, calc_ell, cut):
        """Update ellipsoid core function using the cut
                g' * (x - xc) + beta <= 0

        Arguments:
            calc_ell {[type]} -- [description]
            g {array} -- cut
            beta {array or scalar} -- [description]

        Returns:
            status -- 0: success
            tau -- "volumn" of ellipsoid
        """
        g, beta = cut
        Qg = self.Q.dot(g)
        omega = g.dot(Qg)
        tsq = self.kappa * omega
        if tsq <= 0.:
            return 4, 0.
        # tau = np.sqrt(self.kappa * tsq)
        # if tau < 0.00000001:
        #     return 2, tau
        # alpha = beta / tau
        status, params = calc_ell(beta, tsq)
        if status != 0:
            return status, tsq
        rho, sigma, delta = params
        self._xc -= (rho / omega) * Qg
        self.Q -= (sigma / omega) * np.outer(Qg, Qg)
        self.kappa *= delta
        # print(np.linalg.det(self.Q), self.kappa)
        return status, tsq

    def calc_ll(self, beta, tsq):
        '''parallel or deep cut'''
        if np.isscalar(beta):
            return self.calc_dc(beta, tsq)

        h0 = beta[0]
        if len(beta) < 2:
            return self.calc_dc(h0, tsq)

        h1 = beta[1]
        t1 = tsq - h1**2
        if t1 < 0. or not self.use_parallel:
            return self.calc_dc(h0, tsq)

        l = h1 - h0
        if l < 0:
            return 1, None  # no sol'n

        n = self._n
        p = h0*h1        
        if n*p < -tsq:
            return 3, None  # no effect

        # parallel cut
        if h0 == 0:
            params = self.calc_ll_cc(h1, tsq, n)
        else:
            t0 = tsq - h0*h0
            h = (h0 + h1)/2
            xi = math.sqrt(t0*t1 + (n*h*l)**2)
            sigma = (n + 2*(tsq - p - xi)/(h*h)) / (n + 1)
            rho = sigma * h
            delta = self.c1 * ((t0 + t1)/2 + xi/n) / tsq
            params = rho, sigma, delta

        return 0, params

    def update(self, cut):
        return self.update_core(self.calc_ll, cut)

    def calc_cc(self, tsq):
        '''central cut'''
        sigma = 2. / (self._n + 1)
        rho = sigma * math.sqrt(tsq) / 2
        delta = self.c1
        return rho, sigma, delta

    def calc_dc(self, h0, tsq):
        '''deep cut'''
        if h0 == 0.:
            return 0, self.calc_cc(tsq)

        l = tsq - h0*h0
        if l < 0.:
            return 1, None    # no sol'n

        n = self._n
        tau = math.sqrt(tsq)
        gamma = tau + n * h0
        if gamma < 0.:
            return 3, None  # no effect

        rho = gamma / (n + 1)
        sigma = 2. * rho / (tau + h0)
        delta = self.c1 * l/tsq
        params = (rho, sigma, delta)
        return 0, params


    def calc_ll_cc(self, h1, tsq, n):
        """Situation when feasible cut."""
        hsq1 = h1**2
        xi = math.sqrt((n*hsq1/2)**2 + tsq*(tsq - hsq1))
        sigma = (n + 8*(tsq - xi) / hsq1) / (n + 1)
        rho = sigma * h1 / 2
        delta = self.c1*(tsq - hsq1/2 - xi/n)/tsq
        return rho, sigma, delta


class ell1d:

    def __init__(self, I):
        l, u = I
        self.r = (u - l)/2
        self._xc = l + self.r

    def copy(self):
        E = ell1d([self._xc - self.r,
                   self._xc + self.r])
        return E

    @property
    def xc(self):
        return self._xc

    @xc.setter
    def xc(self, x):
        self._xc = x

    def update(self, cut):
        """Update ellipsoid core function using the cut
                g' * (x - xc) + beta <= 0

        Arguments:
            g {floay} -- cut
            beta {array or scalar} -- [description]

        Returns:
            status -- 0: success
            tau -- "volumn" of ellipsoid
        """
        g, beta = cut
        tau = abs(self.r * g)
        tsq = tau**2
        if beta == 0.:
            self.r /= 2
            if g > 0.:
                self._xc -= self.r
            else:
                self._xc += self.r
            return 0, tsq
        if beta > tau:
            return 1, tsq  # no sol'n
        if beta < -tau:
            return 3, tsq  # no effect

        bound = self._xc - beta / g
        if g > 0.:
            u = bound
            l = self._xc - self.r
        else:
            l = bound
            u = self._xc + self.r
        self.r = (u - l)/2
        self._xc = l + self.r
        return 0, tsq
